const{PI:PI,sin:sin,cos:cos,acos:acos,atan2:atan2,sqrt:sqrt,random:random,abs:abs}=Math;class Vec2{constructor(t=0,s=0){this.x=t,this.y=s}static add(t,s){return new Vec2(t.x+s.x,t.y+s.y)}static angleBetween(t,s){return atan2(t.x*s.y-t.y*s.x,t.x*s.x+t.y*s.y)}static distance(t,s){return sqrt((t.x-s.x)**2+(t.y-s.y)**2)}static distanceChebyshev(t,s){const i=abs(t.x-s.x),h=abs(t.y-s.y);return i>=h?i:h}static distanceManhattan(t,s){return abs(t.x-s.x)+abs(t.y-s.y)}static distanceMinkowski(t,s,i){return(abs(t.x-s.x)**i+abs(t.y-s.y)**i)**(1/i)}static distanceSq(t,s){return(t.x-s.x)**2+(t.y-s.y)**2}static dot(t,s){return t.x*s.x+t.y*s.y}static fromPolarCoords(t,s){return new Vec2(t*cos(s),t*sin(s))}static isInfinite(t){return t.x===1/0||t.x===-1/0||t.y===1/0||t.y===-1/0}static isNaN(t){return isNaN(t.x)||isNaN(t.y)}static isZero(t){return 0===t.x&&0===t.y}static lerp(t,s,i){return i>1?i=1:i<0&&(i=0),new Vec2(t.x+(s.x-t.x)*i,t.y+(s.y-t.y)*i)}static negate(t){return new Vec2(-t.x,-t.y)}static normalize(t){const s=t.magnitude;return new Vec2(t.x/s,t.y/s)}static project(t,s){const i=s.magnitude,h=t.magnitude*cos(atan2(t.x*s.y-t.y*s.x,t.x*s.x+t.y*s.y));return new Vec2(s.x/i*h,s.y/i*h)}static random(){const t=random()*PI*2;return new Vec2(cos(t),sin(t))}static satisfyEquality(t,s){return t.x===s.x&&t.y===s.y}static satisfyOpposition(t,s){return t.x===-s.x&&t.y===-s.y}static scale(t,s){return new Vec2(t.x*s,t.y*s)}static subtract(t,s){return new Vec2(t.x-s.x,t.y-s.y)}get angleX(){return atan2(this.y,this.x)+(this.y<0?2*PI:0)}get angleY(){return-atan2(this.x,this.y)+(this.x>0?2*PI:0)}get magnitude(){return sqrt(this.x**2+this.y**2)}get magnitudeSq(){return this.x**2+this.y**2}get xy(){return[this.x,this.y]}set angleX(t){const s=this.magnitude;this.x=s*cos(t),this.y=s*sin(t)}set angleY(t){const s=this.magnitude;this.x=s*-sin(t),this.y=s*cos(t)}set magnitude(t){const s=this.magnitude;this.x=this.x/s*t,this.y=this.y/s*t}set xy(t){this.x=t[0],this.y=t[1]}add(t){return this.x+=t.x,this.y+=t.y,this}angleBetween(t){return atan2(this.x*t.y-this.y*t.x,this.x*t.x+this.y*t.y)}clamp(t,s){const i=this.magnitude;return i>s?(this.x=this.x/i*s,this.y=this.y/i*s):i<t&&(this.x=this.x/i*t,this.y=this.y/i*t),this}clone(){return new Vec2(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}distance(t){return sqrt((this.x-t.x)**2+(this.y-t.y)**2)}distanceSq(t){return(this.x-t.x)**2+(this.y-t.y)**2}dot(t){return this.x*t.x+this.y*t.y}isInfinite(){return this.x===1/0||this.x===-1/0||this.y===1/0||this.y===-1/0}isNaN(){return isNaN(this.x)||isNaN(this.y)}isZero(){return 0===this.x&&0===this.y}limitMax(t){const s=this.magnitude;return s>t&&(this.x=this.x/s*t,this.y=this.y/s*t),this}limitMin(t){const s=this.magnitude;return s<t&&(this.x=this.x/s*t,this.y=this.y/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.x=t.x/i*s,this.y=t.y/i*s,this}negate(){return this.x*=-1,this.y*=-1,this}normalize(){const t=this.magnitude;return this.x/=t,this.y/=t,this}project(t){const s=t.magnitude,i=this.magnitude*cos(atan2(this.x*t.y-this.y*t.x,this.x*t.x+this.y*t.y));return this.x=t.x/s*i,this.y=t.y/s*i,this}random(){const t=random()*PI*2,s=this.magnitude;return this.x=s*cos(t),this.y=s*sin(t),this}rotateZ(t){const s=cos(t),i=sin(t),h=this.x;return this.x=this.x*s-this.y*i,this.y=h*i+this.y*s,this}satisfyEquality(t){return this.x===t.x&&this.y===t.y}satisfyOpposition(t){return this.x===-t.x&&this.y===-t.y}scale(t){return this.x*=t,this.y*=t,this}subtract(t){return this.x-=t.x,this.y-=t.y,this}turnLeft(){const t=this.x;return this.x=-this.y,this.y=t,this}turnRight(){const t=this.x;return this.x=this.y,this.y=-t,this}zero(){return this.x=0,this.y=0,this}*[Symbol.iterator](){yield this.x,yield this.y}}class Vec3{constructor(t=0,s=0,i=0){this.x=t,this.y=s,this.z=i}static add(t,s){return new Vec3(t.x+s.x,t.y+s.y,t.z+s.z)}static angleBetween(t,s){return acos((t.x*s.x+t.y*s.y+t.z*s.z)/(t.magnitude*s.magnitude))}static cross(t,s){return new Vec3(t.y*s.z-t.z*s.y,t.z*s.x-t.x*s.z,t.x*s.y-t.y*s.x)}static distance(t,s){return sqrt((t.x-s.x)**2+(t.y-s.y)**2+(t.z-s.z)**2)}static distanceChebyshev(t,s){const i=abs(t.x-s.x),h=abs(t.y-s.y),e=abs(t.z-s.z);return i>=h&&i>=e?i:h>=e?h:e}static distanceManhattan(t,s){return abs(t.x-s.x)+abs(t.y-s.y)+abs(t.z-s.z)}static distanceMinkowski(t,s,i){return(abs(t.x-s.x)**i+abs(t.y-s.y)**i+abs(t.z-s.z)**i)**(1/i)}static distanceSq(t,s){return(t.x-s.x)**2+(t.y-s.y)**2+(t.z-s.z)**2}static dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z}static fromCylindricalCoords(t,s,i){return new Vec3(t*cos(s),t*sin(s),i)}static fromSphericalCoords(t,s,i){return new Vec3(t*sin(s)*cos(i),t*sin(s)*sin(i),t*cos(s))}static isInfinite(t){return t.x===1/0||t.x===-1/0||t.y===1/0||t.y===-1/0||t.z===1/0||t.z===-1/0}static isNaN(t){return isNaN(t.x)||isNaN(t.y)||isNaN(t.z)}static isZero(t){return 0===t.x&&0===t.y&&0===t.z}static lerp(t,s,i){return i>1?i=1:i<0&&(i=0),new Vec3(t.x+(s.x-t.x)*i,t.y+(s.y-t.y)*i,t.z+(s.z-t.z)*i)}static negate(t){return new Vec3(-t.x,-t.y,-t.z)}static normalize(t){const s=t.magnitude;return new Vec3(t.x/s,t.y/s,t.z/s)}static project(t,s){const i=t.magnitude,h=s.magnitude,e=i*cos(acos((t.x*s.x+t.y*s.y+t.z*s.z)/(i*h)));return new Vec3(s.x/h*e,s.y/h*e,s.z/h*e)}static random(){let t,s;do{t=2*random()-1,s=2*random()-1}while(t**2+s**2>=1);const i=sqrt(1-t**2-s**2);return new Vec3(2*t*i,2*s*i,1-2*(t**2+s**2))}static satisfyEquality(t,s){return t.x===s.x&&t.y===s.y&&t.z===s.z}static satisfyOpposition(t,s){return t.x===-s.x&&t.y===-s.y&&t.z===-s.z}static scale(t,s){return new Vec3(t.x*s,t.y*s,t.z*s)}static subtract(t,s){return new Vec3(t.x-s.x,t.y-s.y,t.z-s.z)}get angleX(){return atan2(sqrt(this.y**2+this.z**2),this.x)}get angleY(){return atan2(sqrt(this.z**2+this.x**2),this.y)}get angleZ(){return atan2(sqrt(this.x**2+this.y**2),this.z)}get b(){return this.z}get g(){return this.y}get magnitude(){return sqrt(this.x**2+this.y**2+this.z**2)}get magnitudeSq(){return this.x**2+this.y**2+this.z**2}get r(){return this.x}get rgb(){return[this.x,this.y,this.z]}get xyz(){return[this.x,this.y,this.z]}set b(t){this.z=t}set g(t){this.y=t}set magnitude(t){const s=this.magnitude;this.x=this.x/s*t,this.y=this.y/s*t,this.z=this.z/s*t}set r(t){this.x=t}set rgb(t){this.x=t[0],this.y=t[1],this.z=t[2]}set xyz(t){this.x=t[0],this.y=t[1],this.z=t[2]}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}angleBetween(t){return acos((this.x*t.x+this.y*t.y+this.z*t.z)/(this.magnitude*t.magnitude))}clamp(t,s){const i=this.magnitude;return i>s?(this.x=this.x/i*s,this.y=this.y/i*s,this.z=this.z/i*s):i<t&&(this.x=this.x/i*t,this.y=this.y/i*t,this.z=this.z/i*t),this}clone(){return new Vec3(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}cross(t){const s=this.x,i=this.y;return this.x=this.y*t.z-this.z*t.y,this.y=this.z*t.x-s*t.z,this.z=s*t.y-i*t.x,this}distance(t){return sqrt((this.x-t.x)**2+(this.y-t.y)**2+(this.z-t.z)**2)}distanceSq(t){return(this.x-t.x)**2+(this.y-t.y)**2+(this.z-t.z)**2}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isInfinite(){return this.x===1/0||this.x===-1/0||this.y===1/0||this.y===-1/0||this.z===1/0||this.z===-1/0}isNaN(){return isNaN(this.x)||isNaN(this.y)||isNaN(this.z)}isZero(){return 0===this.x&&0===this.y&&0===this.z}limitMax(t){const s=this.magnitude;return s>t&&(this.x=this.x/s*t,this.y=this.y/s*t,this.z=this.z/s*t),this}limitMin(t){const s=this.magnitude;return s<t&&(this.x=this.x/s*t,this.y=this.y/s*t,this.z=this.z/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.x=t.x/i*s,this.y=t.y/i*s,this.z=t.z/i*s,this}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}normalize(){const t=this.magnitude;return this.x/=t,this.y/=t,this.z/=t,this}project(t){const s=this.magnitude,i=t.magnitude,h=s*cos(acos((this.x*t.x+this.y*t.y+this.z*t.z)/(s*i)));return this.x=t.x/i*h,this.y=t.y/i*h,this.z=t.z/i*h,this}random(){let t,s;do{t=2*random()-1,s=2*random()-1}while(t**2+s**2>=1);const i=sqrt(1-t**2-s**2),h=this.magnitude;return this.x=2*h*t*i,this.y=2*h*s*i,this.z=h*(1-2*(t**2+s**2)),this}rotateX(t){const s=cos(t),i=sin(t),h=this.y;return this.y=this.y*s-this.z*i,this.z=h*i+this.z*s,this}rotateY(t){const s=cos(t),i=sin(t),h=this.x;return this.x=this.x*s+this.z*i,this.z=h*i+this.z*s,this}rotateZ(t){const s=cos(t),i=sin(t),h=this.x;return this.x=this.x*s-this.y*i,this.y=h*i+this.y*s,this}satisfyEquality(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}satisfyOpposition(t){return this.x===-t.x&&this.y===-t.y&&this.z===-t.z}scale(t){return this.x*=t,this.y*=t,this.z*=t,this}subtract(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}zero(){return this.x=0,this.y=0,this.z=0,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}class Vec4{constructor(t=0,s=0,i=0,h=0){this.x=t,this.y=s,this.z=i,this.w=h}static add(t,s){return new Vec4(t.x+s.x,t.y+s.y,t.z+s.z,t.w+s.w)}static angleBetween(t,s){return acos((t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w)/(t.magnitude*s.magnitude))}static distance(t,s){return sqrt((t.x-s.x)**2+(t.y-s.y)**2+(t.z-s.z)**2+(t.w-s.w)**2)}static distanceChebyshev(t,s){const i=abs(t.x-s.x),h=abs(t.y-s.y),e=abs(t.z-s.z),n=abs(t.w-s.w);return i>=h&&i>=e&&i>=n?i:h>=e&&h>=n?h:e>=n?e:n}static distanceManhattan(t,s){return abs(t.x-s.x)+abs(t.y-s.y)+abs(t.z-s.z)+abs(t.w-s.w)}static distanceMinkowski(t,s,i){return(abs(t.x-s.x)**i+abs(t.y-s.y)**i+abs(t.z-s.z)**i+abs(t.w-s.w)**i)**(1/i)}static distanceSq(t,s){return(t.x-s.x)**2+(t.y-s.y)**2+(t.z-s.z)**2+(t.w-s.w)**2}static dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w}static isInfinite(t){return t.x===1/0||t.x===-1/0||t.y===1/0||t.y===-1/0||t.z===1/0||t.z===-1/0||t.w===1/0||t.w===-1/0}static isNaN(t){return isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||isNaN(t.w)}static isZero(t){return 0===t.x&&0===t.y&&0===t.z&&0===t.w}static lerp(t,s,i){return i>1?i=1:i<0&&(i=0),new Vec4(t.x+(s.x-t.x)*i,t.y+(s.y-t.y)*i,t.z+(s.z-t.z)*i,t.w+(s.w-t.w)*i)}static negate(t){return new Vec4(-t.x,-t.y,-t.z,-t.w)}static normalize(t){const s=t.magnitude;return new Vec4(t.x/s,t.y/s,t.z/s,t.w/s)}static project(t,s){const i=t.magnitude,h=s.magnitude,e=i*cos(acos((t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w)/(i*h)));return new Vec4(s.x/h*e,s.y/h*e,s.z/h*e,s.w/h*e)}static random(){let t,s,i,h;do{t=2*random()-1,s=2*random()-1,i=2*random()-1,h=2*random()-1}while(t**2+s**2>=1||i**2+h**2>=1);const e=sqrt((1-t**2-s**2)/(i**2+h**2));return new Vec4(t,s,i*e,h*e)}static satisfyEquality(t,s){return t.x===s.x&&t.y===s.y&&t.z===s.z&&t.w===s.w}static satisfyOpposition(t,s){return t.x===-s.x&&t.y===-s.y&&t.z===-s.z&&t.w===-s.w}static scale(t,s){return new Vec4(t.x*s,t.y*s,t.z*s,t.w*s)}static subtract(t,s){return new Vec4(t.x-s.x,t.y-s.y,t.z-s.z,t.w-s.w)}get a(){return this.w}get angleW(){return atan2(sqrt(this.x**2+this.y**2+this.z**2),this.w)}get angleX(){return atan2(sqrt(this.y**2+this.z**2+this.w**2),this.x)}get angleY(){return atan2(sqrt(this.z**2+this.w**2+this.x**2),this.y)}get angleZ(){return atan2(sqrt(this.w**2+this.x**2+this.y**2),this.z)}get b(){return this.z}get g(){return this.y}get magnitude(){return sqrt(this.x**2+this.y**2+this.z**2+this.w**2)}get magnitudeSq(){return this.x**2+this.y**2+this.z**2+this.w**2}get r(){return this.x}get rgba(){return[this.x,this.y,this.z,this.w]}get xyzw(){return[this.x,this.y,this.z,this.w]}set a(t){this.w=t}set b(t){this.z=t}set g(t){this.y=t}set magnitude(t){const s=this.magnitude;this.x=this.x/s*t,this.y=this.y/s*t,this.z=this.z/s*t,this.w=this.w/s*t}set r(t){this.x=t}set rgba(t){this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3]}set xyzw(t){this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3]}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}angleBetween(t){return acos((this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w)/(this.magnitude*t.magnitude))}clamp(t,s){const i=this.magnitude;return i>s?(this.x=this.x/i*s,this.y=this.y/i*s,this.z=this.z/i*s,this.w=this.w/i*s):i<t&&(this.x=this.x/i*t,this.y=this.y/i*t,this.z=this.z/i*t,this.w=this.w/i*t),this}clone(){return new Vec4(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}distance(t){return sqrt((this.x-t.x)**2+(this.y-t.y)**2+(this.z-t.z)**2+(this.w-t.w)**2)}distanceSq(t){return(this.x-t.x)**2+(this.y-t.y)**2+(this.z-t.z)**2+(this.w-t.w)**2}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}isInfinite(){return this.x===1/0||this.x===-1/0||this.y===1/0||this.y===-1/0||this.z===1/0||this.z===-1/0||this.w===1/0||this.w===-1/0}isNaN(){return isNaN(this.x)||isNaN(this.y)||isNaN(this.z)||isNaN(this.w)}isZero(){return 0===this.x&&0===this.y&&0===this.z&&0===this.w}limitMax(t){const s=this.magnitude;return s>t&&(this.x=this.x/s*t,this.y=this.y/s*t,this.z=this.z/s*t,this.w=this.w/s*t),this}limitMin(t){const s=this.magnitude;return s<t&&(this.x=this.x/s*t,this.y=this.y/s*t,this.z=this.z/s*t,this.w=this.w/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.x=t.x/i*s,this.y=t.y/i*s,this.z=t.z/i*s,this.w=t.w/i*s,this}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}normalize(){const t=this.magnitude;return this.x/=t,this.y/=t,this.z/=t,this.w/=t,this}project(t){const s=this.magnitude,i=t.magnitude,h=s*cos(acos((this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w)/(s*i)));return this.x=t.x/i*h,this.y=t.y/i*h,this.z=t.z/i*h,this.w=t.w/i*h,this}random(){let t,s,i,h;do{t=2*random()-1,s=2*random()-1,i=2*random()-1,h=2*random()-1}while(t**2+s**2>=1||i**2+h**2>=1);const e=sqrt((1-t**2-s**2)/(i**2+h**2)),n=this.magnitude;return this.x=n*t,this.y=n*s,this.z=n*i*e,this.w=n*h*e,this}satisfyEquality(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}satisfyOpposition(t){return this.x===-t.x&&this.y===-t.y&&this.z===-t.z&&this.w===-t.w}scale(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}subtract(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}zero(){return this.x=0,this.y=0,this.z=0,this.w=0,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}export{Vec2,Vec3,Vec4};