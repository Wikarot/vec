/**
 * Inspired by GLSL and thought to hit the *highest possible performance* in
 * JavaScript, vec.js makes it possible to **create and operate with vectors**.
 * @summary JavaScript vector library.
 * @version 2.0.0
 * @copyright Copyright (c) Leonardo de S.L.F, 2018-present.
 * @author Leonardo de S.L.F
 * @license MIT
 */
"use strict";const{PI:PI,sin:sin,cos:cos,acos:acos,atan2:atan2,sqrt:sqrt,random:random,abs:abs}=Math;class Vec2{#t;#s;constructor(t=null,s=null){this.#t=Number(t),this.#s=Number(s)}static add(t,s){return new Vec2(t.#t+s.#t,t.#s+s.#s)}static angleBetween(t,s){return atan2(t.#t*s.#s-t.#s*s.#t,t.#t*s.#t+t.#s*s.#s)}static distance(t,s){return sqrt((t.#t-s.#t)**2+(t.#s-s.#s)**2)}static distanceChebyshev(t,s){const i=abs(t.#t-s.#t),e=abs(t.#s-s.#s);return i>=e?i:e}static distanceManhattan(t,s){return abs(t.#t-s.#t)+abs(t.#s-s.#s)}static distanceMinkowski(t,s,i){return i=Number(i),(abs(t.#t-s.#t)**i+abs(t.#s-s.#s)**i)**(1/i)}static distanceSq(t,s){return(t.#t-s.#t)**2+(t.#s-s.#s)**2}static dot(t,s){return t.#t*s.#t+t.#s*s.#s}static fromPolarCoords(t=null,s=null){return t=Number(t),s=Number(s),new Vec2(t*cos(s),t*sin(s))}static isInfinite(t){return t.#t===1/0||t.#t===-1/0||t.#s===1/0||t.#s===-1/0}static isNaN(t){return isNaN(t.#t)||isNaN(t.#s)}static isZero(t){return 0===t.#t&&0===t.#s}static lerp(t,s,i=null){return(i=Number(i))>1?i=1:i<0&&(i=0),new Vec2(t.#t+(s.#t-t.#t)*i,t.#s+(s.#s-t.#s)*i)}static negate(t){return new Vec2(-t.#t,-t.#s)}static normalize(t){const s=t.magnitude;return new Vec2(t.#t/s,t.#s/s)}static project(t,s){const i=s.magnitude,e=t.magnitude*cos(atan2(t.#t*s.#s-t.#s*s.#t,t.#t*s.#t+t.#s*s.#s));return new Vec2(s.#t/i*e,s.#s/i*e)}static random(){const t=random()*PI*2;return new Vec2(cos(t),sin(t))}static satisfyEquality(t,s){return t.#t===s.#t&&t.#s===s.#s}static satisfyOpposition(t,s){return t.#t===-s.#t&&t.#s===-s.#s}static scale(t,s=null){return s=Number(s),new Vec2(t.#t*s,t.#s*s)}static subtract(t,s){return new Vec2(t.#t-s.#t,t.#s-s.#s)}get angleX(){return atan2(this.#s,this.#t)+(this.#s<0?2*PI:0)}get angleY(){return-atan2(this.#t,this.#s)+(this.#t>0?2*PI:0)}get magnitude(){return sqrt(this.#t**2+this.#s**2)}get magnitudeSq(){return this.#t**2+this.#s**2}get x(){return this.#t}get xy(){return[this.#t,this.#s]}get y(){return this.#s}set angleX(t=null){t=Number(t);const s=this.magnitude;this.#t=s*cos(t),this.#s=s*sin(t)}set angleY(t=null){t=Number(t);const s=this.magnitude;this.#t=s*-sin(t),this.#s=s*cos(t)}set magnitude(t=null){t=Number(t);const s=this.magnitude;this.#t=this.#t/s*t,this.#s=this.#s/s*t}set x(t=null){this.#t=Number(t)}set xy(t){this.x=t[0],this.y=t[1]}set y(t=null){this.#s=Number(t)}add(t){return this.#t+=t.#t,this.#s+=t.#s,this}angleBetween(t){return atan2(this.#t*t.#s-this.#s*t.#t,this.#t*t.#t+this.#s*t.#s)}clamp(t=null,s=null){t=Number(t),s=Number(s);const i=this.magnitude;return i>s?(this.#t=this.#t/i*s,this.#s=this.#s/i*s):i<t&&(this.#t=this.#t/i*t,this.#s=this.#s/i*t),this}clone(){return new Vec2(this.#t,this.#s)}copy(t){return this.#t=t.#t,this.#s=t.#s,this}distance(t){return sqrt((this.#t-t.#t)**2+(this.#s-t.#s)**2)}distanceSq(t){return(this.#t-t.#t)**2+(this.#s-t.#s)**2}dot(t){return this.#t*t.#t+this.#s*t.#s}isInfinite(){return this.#t===1/0||this.#t===-1/0||this.#s===1/0||this.#s===-1/0}isNaN(){return isNaN(this.#t)||isNaN(this.#s)}isZero(){return 0===this.#t&&0===this.#s}limitMax(t=null){t=Number(t);const s=this.magnitude;return s>t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t),this}limitMin(t=null){t=Number(t);const s=this.magnitude;return s<t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.#t=t.#t/i*s,this.#s=t.#s/i*s,this}negate(){return this.#t*=-1,this.#s*=-1,this}normalize(){const t=this.magnitude;return this.#t/=t,this.#s/=t,this}project(t){const s=t.magnitude,i=this.magnitude*cos(atan2(this.#t*t.#s-this.#s*t.#t,this.#t*t.#t+this.#s*t.#s));return this.#t=t.#t/s*i,this.#s=t.#s/s*i,this}random(){const t=random()*PI*2,s=this.magnitude;return this.#t=s*cos(t),this.#s=s*sin(t),this}rotateZ(t=null){t=Number(t);const s=cos(t),i=sin(t),e=this.#t;return this.#t=this.#t*s-this.#s*i,this.#s=e*i+this.#s*s,this}satisfyEquality(t){return this.#t===t.#t&&this.#s===t.#s}satisfyOpposition(t){return this.#t===-t.#t&&this.#s===-t.#s}scale(t=null){return t=Number(t),this.#t*=t,this.#s*=t,this}subtract(t){return this.#t-=t.#t,this.#s-=t.#s,this}turnLeft(){const t=this.#t;return this.#t=-this.#s,this.#s=t,this}turnRight(){const t=this.#t;return this.#t=this.#s,this.#s=-t,this}zero(){return this.#t=0,this.#s=0,this}}class Vec3{#t;#s;#i;constructor(t=null,s=null,i=null){this.#t=Number(t),this.#s=Number(s),this.#i=Number(i)}static add(t,s){return new Vec3(t.#t+s.#t,t.#s+s.#s,t.#i+s.#i)}static angleBetween(t,s){return acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i)/(t.magnitude*s.magnitude))}static cross(t,s){return new Vec3(t.#s*s.#i-t.#i*s.#s,t.#i*s.#t-t.#t*s.#i,t.#t*s.#s-t.#s*s.#t)}static distance(t,s){return sqrt((t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2)}static distanceChebyshev(t,s){const i=abs(t.#t-s.#t),e=abs(t.#s-s.#s),h=abs(t.#i-s.#i);return i>=e&&i>=h?i:e>=h?e:h}static distanceManhattan(t,s){return abs(t.#t-s.#t)+abs(t.#s-s.#s)+abs(t.#i-s.#i)}static distanceMinkowski(t,s,i){return i=Number(i),(abs(t.#t-s.#t)**i+abs(t.#s-s.#s)**i+abs(t.#i-s.#i)**i)**(1/i)}static distanceSq(t,s){return(t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2}static dot(t,s){return t.#t*s.#t+t.#s*s.#s+t.#i*s.#i}static fromCylindricalCoords(t,s,i){return new Vec3(t*cos(s),t*sin(s),i)}static fromSphericalCoords(t,s,i){return new Vec3(t*sin(s)*cos(i),t*sin(s)*sin(i),t*cos(s))}static isInfinite(t){return t.#t===1/0||t.#t===-1/0||t.#s===1/0||t.#s===-1/0||t.#i===1/0||t.#i===-1/0}static isNaN(t){return isNaN(t.#t)||isNaN(t.#s)||isNaN(t.#i)}static isZero(t){return 0===t.#t&&0===t.#s&&0===t.#i}static lerp(t,s,i=null){return(i=Number(i))>1?i=1:i<0&&(i=0),new Vec3(t.#t+(s.#t-t.#t)*i,t.#s+(s.#s-t.#s)*i,t.#i+(s.#i-t.#i)*i)}static negate(t){return new Vec3(-t.#t,-t.#s,-t.#i)}static normalize(t){const s=t.magnitude;return new Vec3(t.#t/s,t.#s/s,t.#i/s)}static project(t,s){const i=t.magnitude,e=s.magnitude,h=i*cos(acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i)/(i*e)));return new Vec3(s.#t/e*h,s.#s/e*h,s.#i/e*h)}static random(){let t,s;do{t=2*random()-1,s=2*random()-1}while(t**2+s**2>=1);const i=sqrt(1-t**2-s**2);return new Vec3(2*t*i,2*s*i,1-2*(t**2+s**2))}static satisfyEquality(t,s){return t.#t===s.#t&&t.#s===s.#s&&t.#i===s.#i}static satisfyOpposition(t,s){return t.#t===-s.#t&&t.#s===-s.#s&&t.#i===-s.#i}static scale(t,s=null){return s=Number(s),new Vec3(t.#t*s,t.#s*s,t.#i*s)}static subtract(t,s){return new Vec3(t.#t-s.#t,t.#s-s.#s,t.#i-s.#i)}get angleX(){return atan2(sqrt(this.#s**2+this.#i**2),this.#t)}get angleY(){return atan2(sqrt(this.#i**2+this.#t**2),this.#s)}get angleZ(){return atan2(sqrt(this.#t**2+this.#s**2),this.#i)}get b(){return this.#i}get g(){return this.#s}get magnitude(){return sqrt(this.#t**2+this.#s**2+this.#i**2)}get magnitudeSq(){return this.#t**2+this.#s**2+this.#i**2}get r(){return this.#t}get rgb(){return[this.#t,this.#s,this.#i]}get x(){return this.#t}get xyz(){return[this.#t,this.#s,this.#i]}get y(){return this.#s}get z(){return this.#i}set b(t=null){this.#i=Number(t)}set g(t=null){this.#s=Number(t)}set magnitude(t=null){t=Number(t);const s=this.magnitude;this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t}set r(t=null){this.#t=Number(t)}set rgb(t){this.x=t[0],this.y=t[1],this.z=t[2]}set x(t=null){this.#t=Number(t)}set xyz(t){this.x=t[0],this.y=t[1],this.z=t[2]}set y(t=null){this.#s=Number(t)}set z(t=null){this.#i=Number(t)}add(t){return this.#t+=t.#t,this.#s+=t.#s,this.#i+=t.#i,this}angleBetween(t){return acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i)/(this.magnitude*t.magnitude))}clamp(t=null,s=null){t=Number(t),s=Number(s);const i=this.magnitude;return i>s?(this.#t=this.#t/i*s,this.#s=this.#s/i*s,this.#i=this.#i/i*s):i<t&&(this.#t=this.#t/i*t,this.#s=this.#s/i*t,this.#i=this.#i/i*t),this}clone(){return new Vec3(this.#t,this.#s,this.#i)}copy(t){return this.#t=t.#t,this.#s=t.#s,this.#i=t.#i,this}cross(t){const s=this.#t,i=this.#s;return this.#t=this.#s*t.#i-this.#i*t.#s,this.#s=this.#i*t.#t-s*t.#i,this.#i=s*t.#s-i*t.#t,this}distance(t){return sqrt((this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2)}distanceSq(t){return(this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2}dot(t){return this.#t*t.#t+this.#s*t.#s+this.#i*t.#i}isInfinite(){return this.#t===1/0||this.#t===-1/0||this.#s===1/0||this.#s===-1/0||this.#i===1/0||this.#i===-1/0}isNaN(){return isNaN(this.#t)||isNaN(this.#s)||isNaN(this.#i)}isZero(){return 0===this.#t&&0===this.#s&&0===this.#i}limitMax(t=null){t=Number(t);const s=this.magnitude;return s>t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t),this}limitMin(t=null){t=Number(t);const s=this.magnitude;return s<t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.#t=t.#t/i*s,this.#s=t.#s/i*s,this.#i=t.#i/i*s,this}negate(){return this.#t*=-1,this.#s*=-1,this.#i*=-1,this}normalize(){const t=this.magnitude;return this.#t/=t,this.#s/=t,this.#i/=t,this}project(t){const s=this.magnitude,i=t.magnitude,e=s*cos(acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i)/(s*i)));return this.#t=t.#t/i*e,this.#s=t.#s/i*e,this.#i=t.#i/i*e,this}random(){let t,s;do{t=2*random()-1,s=2*random()-1}while(t**2+s**2>=1);const i=sqrt(1-t**2-s**2),e=this.magnitude;return this.#t=2*e*t*i,this.#s=2*e*s*i,this.#i=e*(1-2*(t**2+s**2)),this}rotateX(t=null){t=Number(t);const s=cos(t),i=sin(t),e=this.#s;return this.#s=this.#s*s-this.#i*i,this.#i=e*i+this.#i*s,this}rotateY(t=null){t=Number(t);const s=cos(t),i=sin(t),e=this.#t;return this.#t=this.#t*s+this.#i*i,this.#i=e*i+this.#i*s,this}rotateZ(t=null){t=Number(t);const s=cos(t),i=sin(t),e=this.#t;return this.#t=this.#t*s-this.#s*i,this.#s=e*i+this.#s*s,this}satisfyEquality(t){return this.#t===t.#t&&this.#s===t.#s&&this.#i===t.#i}satisfyOpposition(t){return this.#t===-t.#t&&this.#s===-t.#s&&this.#i===-t.#i}scale(t=null){return t=Number(t),this.#t*=t,this.#s*=t,this.#i*=t,this}subtract(t){return this.#t-=t.#t,this.#s-=t.#s,this.#i-=t.#i,this}zero(){return this.#t=0,this.#s=0,this.#i=0,this}}class Vec4{#t;#s;#i;#e;constructor(t=null,s=null,i=null,e=null){this.#t=Number(t),this.#s=Number(s),this.#i=Number(i),this.#e=Number(e)}static add(t,s){return new Vec4(t.#t+s.#t,t.#s+s.#s,t.#i+s.#i,t.#e+s.#e)}static angleBetween(t,s){return acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i+t.#e*s.#e)/(t.magnitude*s.magnitude))}static distance(t,s){return sqrt((t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2+(t.#e-s.#e)**2)}static distanceChebyshev(t,s){const i=abs(t.#t-s.#t),e=abs(t.#s-s.#s),h=abs(t.#i-s.#i),r=abs(t.#e-s.#e);return i>=e&&i>=h&&i>=r?i:e>=h&&e>=r?e:h>=r?h:r}static distanceManhattan(t,s){return abs(t.#t-s.#t)+abs(t.#s-s.#s)+abs(t.#i-s.#i)+abs(t.#e-s.#e)}static distanceMinkowski(t,s,i){return i=Number(i),(abs(t.#t-s.#t)**i+abs(t.#s-s.#s)**i+abs(t.#i-s.#i)**i+abs(t.#e-s.#e)**i)**(1/i)}static distanceSq(t,s){return(t.#t-s.#t)**2+(t.#s-s.#s)**2+(t.#i-s.#i)**2+(t.#e-s.#e)**2}static dot(t,s){return t.#t*s.#t+t.#s*s.#s+t.#i*s.#i+t.#e*s.#e}static isInfinite(t){return t.#t===1/0||t.#t===-1/0||t.#s===1/0||t.#s===-1/0||t.#i===1/0||t.#i===-1/0||t.#e===1/0||t.#e===-1/0}static isNaN(t){return isNaN(t.#t)||isNaN(t.#s)||isNaN(t.#i)||isNaN(t.#e)}static isZero(t){return 0===t.#t&&0===t.#s&&0===t.#i&&0===t.#e}static lerp(t,s,i=null){return(i=Number(i))>1?i=1:i<0&&(i=0),new Vec4(t.#t+(s.#t-t.#t)*i,t.#s+(s.#s-t.#s)*i,t.#i+(s.#i-t.#i)*i,t.#e+(s.#e-t.#e)*i)}static negate(t){return new Vec4(-t.#t,-t.#s,-t.#i,-t.#e)}static normalize(t){const s=t.magnitude;return new Vec4(t.#t/s,t.#s/s,t.#i/s,t.#e/s)}static project(t,s){const i=t.magnitude,e=s.magnitude,h=i*cos(acos((t.#t*s.#t+t.#s*s.#s+t.#i*s.#i+t.#e*s.#e)/(i*e)));return new Vec4(s.#t/e*h,s.#s/e*h,s.#i/e*h,s.#e/e*h)}static random(){let t,s,i,e;do{t=2*random()-1,s=2*random()-1,i=2*random()-1,e=2*random()-1}while(t**2+s**2>=1||i**2+e**2>=1);const h=sqrt((1-t**2-s**2)/(i**2+e**2));return new Vec4(t,s,i*h,e*h)}static satisfyEquality(t,s){return t.#t===s.#t&&t.#s===s.#s&&t.#i===s.#i&&t.#e===s.#e}static satisfyOpposition(t,s){return t.#t===-s.#t&&t.#s===-s.#s&&t.#i===-s.#i&&t.#e===-s.#e}static scale(t,s=null){return s=Number(s),new Vec4(t.#t*s,t.#s*s,t.#i*s,t.#e*s)}static subtract(t,s){return new Vec4(t.#t-s.#t,t.#s-s.#s,t.#i-s.#i,t.#e-s.#e)}get a(){return this.#e}get angleW(){return atan2(sqrt(this.#t**2+this.#s**2+this.#i**2),this.#e)}get angleX(){return atan2(sqrt(this.#s**2+this.#i**2+this.#e**2),this.#t)}get angleY(){return atan2(sqrt(this.#i**2+this.#e**2+this.#t**2),this.#s)}get angleZ(){return atan2(sqrt(this.#e**2+this.#t**2+this.#s**2),this.#i)}get b(){return this.#i}get g(){return this.#s}get magnitude(){return sqrt(this.#t**2+this.#s**2+this.#i**2+this.#e**2)}get magnitudeSq(){return this.#t**2+this.#s**2+this.#i**2+this.#e**2}get r(){return this.#t}get rgba(){return[this.#t,this.#s,this.#i,this.#e]}get w(){return this.#e}get x(){return this.#t}get xyzw(){return[this.#t,this.#s,this.#i,this.#e]}get y(){return this.#s}get z(){return this.#i}set a(t=null){this.#e=Number(t)}set b(t=null){this.#i=Number(t)}set g(t=null){this.#s=Number(t)}set magnitude(t=null){t=Number(t);const s=this.magnitude;this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t,this.#e=this.#e/s*t}set r(t=null){this.#t=Number(t)}set rgba(t){this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3]}set w(t=null){this.#e=Number(t)}set x(t=null){this.#t=Number(t)}set xyzw(t){this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3]}set y(t=null){this.#s=Number(t)}set z(t=null){this.#i=Number(t)}add(t){return this.#t+=t.#t,this.#s+=t.#s,this.#i+=t.#i,this.#e+=t.#e,this}angleBetween(t){return acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i+this.#e*t.#e)/(this.magnitude*t.magnitude))}clamp(t=null,s=null){t=Number(t),s=Number(s);const i=this.magnitude;return i>s?(this.#t=this.#t/i*s,this.#s=this.#s/i*s,this.#i=this.#i/i*s,this.#e=this.#e/i*s):i<t&&(this.#t=this.#t/i*t,this.#s=this.#s/i*t,this.#i=this.#i/i*t,this.#e=this.#e/i*t),this}clone(){return new Vec4(this.#t,this.#s,this.#i,this.#e)}copy(t){return this.#t=t.#t,this.#s=t.#s,this.#i=t.#i,this.#e=t.#e,this}distance(t){return sqrt((this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2+(this.#e-t.#e)**2)}distanceSq(t){return(this.#t-t.#t)**2+(this.#s-t.#s)**2+(this.#i-t.#i)**2+(this.#e-t.#e)**2}dot(t){return this.#t*t.#t+this.#s*t.#s+this.#i*t.#i+this.#e*t.#e}isInfinite(){return this.#t===1/0||this.#t===-1/0||this.#s===1/0||this.#s===-1/0||this.#i===1/0||this.#i===-1/0||this.#e===1/0||this.#e===-1/0}isNaN(){return isNaN(this.#t)||isNaN(this.#s)||isNaN(this.#i)||isNaN(this.#e)}isZero(){return 0===this.#t&&0===this.#s&&0===this.#i&&0===this.#e}limitMax(t=null){t=Number(t);const s=this.magnitude;return s>t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t,this.#e=this.#e/s*t),this}limitMin(t=null){t=Number(t);const s=this.magnitude;return s<t&&(this.#t=this.#t/s*t,this.#s=this.#s/s*t,this.#i=this.#i/s*t,this.#e=this.#e/s*t),this}lookAt(t){const s=this.magnitude,i=t.magnitude;return this.#t=t.#t/i*s,this.#s=t.#s/i*s,this.#i=t.#i/i*s,this.#e=t.#e/i*s,this}negate(){return this.#t*=-1,this.#s*=-1,this.#i*=-1,this.#e*=-1,this}normalize(){const t=this.magnitude;return this.#t/=t,this.#s/=t,this.#i/=t,this.#e/=t,this}project(t){const s=this.magnitude,i=t.magnitude,e=s*cos(acos((this.#t*t.#t+this.#s*t.#s+this.#i*t.#i+this.#e*t.#e)/(s*i)));return this.#t=t.#t/i*e,this.#s=t.#s/i*e,this.#i=t.#i/i*e,this.#e=t.#e/i*e,this}random(){let t,s,i,e;do{t=2*random()-1,s=2*random()-1,i=2*random()-1,e=2*random()-1}while(t**2+s**2>=1||i**2+e**2>=1);const h=sqrt((1-t**2-s**2)/(i**2+e**2)),r=this.magnitude;return this.#t=r*t,this.#s=r*s,this.#i=r*i*h,this.#e=r*e*h,this}satisfyEquality(t){return this.#t===t.#t&&this.#s===t.#s&&this.#i===t.#i&&this.#e===t.#e}satisfyOpposition(t){return this.#t===-t.#t&&this.#s===-t.#s&&this.#i===-t.#i&&this.#e===-t.#e}scale(t=null){return t=Number(t),this.#t*=t,this.#s*=t,this.#i*=t,this.#e*=t,this}subtract(t){return this.#t-=t.#t,this.#s-=t.#s,this.#i-=t.#i,this.#e-=t.#e,this}zero(){return this.#t=0,this.#s=0,this.#i=0,this.#e=0,this}}export{Vec2,Vec3,Vec4};